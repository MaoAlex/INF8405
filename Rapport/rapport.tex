\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[pdftex]{graphicx}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=1]{Images/polytechnique_genie_gauche_fr_rgb.png}~\\[1.5cm]

    \textsc{\LARGE École Polytechnique Montréal}\\[2cm]

    \textsc{\Large INF8405 : Informatique Mobile}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries TP1 : FlowFree\\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=1]{Images/logoFF.png}\\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
          Philippe TROCLET \textsc{1815208}\\
          Alexandre  MAO \textsc{1813566}\\
          Fabien  BERQUEZ \textsc{1800325}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Soumis à :} M. Aurel Josas RANDOLF\\
        \emph{Soumis le :} 17 Février 2016 
      \end{flushright}
    \end{minipage}

    \vfill

  \end{center}
  \end{sffamily}
\end{titlepage}


\section{Introduction}
\section{Présentation Technique}
    \subsection{Affichage de la grille}
    Le dessin se fait en stockant des commandes qui tracent des lignes. Ainsi, nous avons une classe \textit{GridLine} qui
    contient les coordonnées des extrémités d'une ligne, lorsqu'on veut tracer la ligne, on appelle la méthode draw de cette
    classe en lui passant le canvas sur lequel on désire tracer la ligne. Les lignes sont créées lors de l'appel à la méthode
    onSizedChanged afin de connaître les dimensions de la place allouée pour la grille. On divise les dimensions par les
    dimensions de la grille (en nombre de cases). Cela nous donne les dimensions en pixels de chaques cases. On peut alors boucler
    pour tracer une droite à chaque multiple des offset sur les deux axes. Cette droite relirerait deux extrémités (verticales ou
    horizontales).
    \newline

    Les différentes lignes sont alors stockées dans une liste, afin de les parcourir dans la méthode onDraw de la vue, pour
    afficher la grille à chaque action de la part du joueur. Dans cette méthode sont également parcourus l'ensemble des éléments
    de la grille afin de leur demander de se redessiner via leur méthode draw. Ces objets seront détaillés dans la section
    suivante.
    \newline

    Il est important de souligner que l'ensemble des objets grahiques sont créés (ou mis à jour selon les cas) dans la méthode
    onSizedChanged, leurs dimensions sont alors calculées à partir des nouvelles dimensions données par la méthode onSizedChanged
    de ce fait, la grille prendra toujours toute la place possible et les divers objets graphique (ronds, traits) auront toujours
    une bonne dimension adaptée à l'écran du téléphone. Cela permet aussi d'avoir un affichage optimal quel que soit le mode
    (porttrait/paysage) dans lequel est le téléphone.
    \subsection{Fonctionnement de la grille}
    La grille de jeu est implémentée dans la classe \textit{FlowFreeSimpleGridView}, cette classe étant la classe \textit{View}
afin de posséder toutes les fonctionnalités d'une vue, pour pouvoir intercepter les mouvements de l'utilisateur sur la surface.
Cette vue possèdera un tableau à deux dimensions (nommé grid) représentant les différentes cases de la grille. On distingue deux
types de cases, les cases classiques et les cases contenant un délimiteur. Les cases contenant un délimiteur dans la mesure où,
elles possèdent un cercle de couleur et surtout leur couleur, à tout instant, est toujours du rond présent sur la case. Nous avons
en effet considéré que qu'afin de pouvoir compléter le jeu, que les ronds soit accessibles à tout instant. En effet, dans le cas
contraire, on pourrait se retrouver bloqué dans l'état inachevé car il nous serait impossible de tracer le dernier tube, et donc
d'atteindre l'état de défaite. De ce fait nous voulions pouvoir stoquer deux classes distinctes au sein d'une même structure. De
plus, ces classes on un fonctionnement très proche: elles doivent pouvoir stocker des éléments de tube de couleurs différentes
tout en conservant l'ordre d'arrivée de ces derniers afin de présenter un un affichage cohérent où le dernier morceau de tube
arrivé sur la case serait celui dessiné en dernier (afin que graphiquement il apparaisse au-dessus de l'autre). Il nous a donc
paru naturel de d'utiliser de l'héritage Avec une classe mère AbsGridElement dont héritent deux classes GridElement et
GridDelimiter (qui représente les cases avec un rond de couleur). La classe mère implémente toutes les fonctionalités qui
permettent à une case de contenir un ou plusieurs tubes et de les gérer, tandis que les classes filles implémente la gestion des
couleurs et les opérations à faire en cas de changement de taille (si on passe du mode portrait au mode paysage par exemple).
\section{Difficultés rencontrées}
\section{Critiques et suggestions}
\end{document}
