\documentclass[12pt, a4paper]{article}%{{{
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[pdftex]{graphicx}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=1]{Images/polytechnique_genie_gauche_fr_rgb.png}~\\[1.5cm]

    \textsc{\LARGE École Polytechnique Montréal}\\[2cm]

    \textsc{\Large INF8405 : Informatique Mobile}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries TP1 : FlowFree\\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=1]{Images/logoFF.png}\\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
          Philippe TROCLET \textsc{1815208}\\
          Alexandre  MAO \textsc{1813566}\\
          Fabien  BERQUEZ \textsc{1800325}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Soumis à :} M. Aurel Josas RANDOLF\\
        \emph{Soumis le :} 17 Février 2016 
      \end{flushright}
    \end{minipage}

    \vfill

  \end{center}
  \end{sffamily}
\end{titlepage}%}}}


\section{Introduction}
	L'objectif de ce laboratoire était de développer une application permettant de joueur au jeu du Flow free sur Android. Le jeu de Flow free dispose de règles assez simple : des paires de jetons de couleur sont placés sur une grille carrée d'une taille donnée (ici pour notre application, 7x7 ou 8x8). Le joueur doit alors relier chaque paire de jetons de l'un à l'autre, en traçant des tubes avec le doigt. La partie est remportée si les jetons de chaque paire sont reliés, que toutes les cases sont occupées par un tube, et qu'il n'y a aucune superposition de tubes sur une même case. Dans le cas où toutes les cases ne sont pas utilisées, la partie est inachevée. Sinon, la partie est perdue.
	\newline
	Les contraintes techniques sur cette application étaient de pouvoir être utilisée sur les versions d'Android supportant l'API 18 (Android 4.3.1) et plus (jusqu'à 23 pour la version actuelle, Android 6). Le jeu devant être adapté pour des supports mobiles variés (tablettes, téléphones intelligents, ...), il doit de plus être jouable entièrement tactilement. Enfin, l'application doit être la plus facile d'accès possible, et proposer à la fois des comportements intuitifs pour les utilisateurs de dispositifs mobiles, et une navigation facile à travers les différentes options possibles.
	\newline
	Pour respecter ces requis non-fonctionnels, nous avons donc opté pour un certain nombre de considérations d'ergonomie, sur les règles du jeu, sur les possibilités offertes au joueur. Nous allons les examiner dans la section suivante.
	
\section{Présentation générale}
	Nous allons présenter dans cette partie les choix que nous avons réalisés pour offrir aux utilisateurs de l'application une navigation et une expérience de jeu que nous espérons aisées et intuitives.
	
	\subsection{Menus de l'application}
	Nous avons opté pour un menu d'accueil proposant trois options : \textit{démarrer} une partie, accéder aux \textit{instructions} et \textit{quitter} l'application.
	Lorsque l'utilisateur choisit de démarrer la partie, un autre menu s'affiche et lui demande de choisir la taille de la grille, puis, une fois celle-ci choisie, l'utilisateur doit choisir le niveau qu'il va jouer. L'écran de jeu s'affiche alors et le joueur peut débuter. Sur les trois écrans mentionnés, l'utilisateur peut à tout moment quitter l'application en utilisant le menu dans la barre de l'application  (symbolisé sur Android 5 et 6 par les 3 points en haut à droite de la barre).
	
	\subsection{Quitter l'application}
	Pour empêcher l'utilisateur de quitter de manière involontaire l'application, le choix de quitter dans les différents menus est soumis à une confirmation, qui se fait par l'intermédiaire d'une fenêtre pop-up offrant deux choix de réponses : Oui et Non.
	
	\subsection{}
		 
\section{Présentation Technique}
    \subsection{Affichage de la grille}
    Le dessin se fait en stockant des commandes qui tracent des lignes. Ainsi, nous avons une classe \textit{GridLine} qui
    contient les coordonnées des extrémités d'une ligne, lorsqu'on veut tracer la ligne, on appelle la méthode draw de cette
    classe en lui passant le canvas sur lequel on désire tracer la ligne. Les lignes sont créées lors de l'appel à la méthode
    onSizedChanged afin de connaître les dimensions de la place allouée pour la grille. On divise les dimensions par les
    dimensions de la grille (en nombre de cases). Cela nous donne les dimensions en pixels de chaques cases. On peut alors boucler
    pour tracer une droite à chaque multiple des offset sur les deux axes. Cette droite relirerait deux extrémités (verticales ou
    horizontales).
    \newline

    Les différentes lignes sont alors stockées dans une liste, afin de les parcourir dans la méthode onDraw de la vue, pour
    afficher la grille à chaque action de la part du joueur. Dans cette méthode sont également parcourus l'ensemble des éléments
    de la grille afin de leur demander de se redessiner via leur méthode draw. Ces objets seront détaillés dans la section
    suivante.
    \newline

    Il est important de souligner que l'ensemble des objets grahiques sont créés (ou mis à jour selon les cas) dans la méthode
    onSizedChanged, leurs dimensions sont alors calculées à partir des nouvelles dimensions données par la méthode onSizedChanged
    de ce fait, la grille prendra toujours toute la place possible et les divers objets graphique (ronds, traits) auront toujours
    une bonne dimension adaptée à l'écran du téléphone. Cela permet aussi d'avoir un affichage optimal quel que soit le mode
    (porttrait/paysage) dans lequel est le téléphone.
    \subsection{Fonctionnement de la grille}
    \subsubsection{La grille}
    La grille de jeu est implémentée dans la classe \textit{FlowFreeSimpleGridView}, cette classe étant la classe \textit{View}
afin de posséder toutes les fonctionnalités d'une vue, pour pouvoir intercepter les mouvements de l'utilisateur sur la surface.
Cette vue possèdera un tableau à deux dimensions (nommé grid) représentant les différentes cases de la grille. On distingue deux
types de cases, les cases classiques et les cases contenant un délimiteur. Les cases contenant un délimiteur dans la mesure où,
elles possèdent un cercle de couleur et surtout leur couleur, à tout instant, est toujours du rond présent sur la case. Nous avons
en effet considéré que qu'afin de pouvoir compléter le jeu, que les ronds soit accessibles à tout instant. En effet, dans le cas
contraire, on pourrait se retrouver bloqué dans l'état inachevé car il nous serait impossible de tracer le dernier tube, et donc
d'atteindre l'état de défaite. De ce fait nous voulions pouvoir stoquer deux classes distinctes au sein d'une même structure. De
plus, ces classes on un fonctionnement très proche: elles doivent pouvoir stocker des éléments de tube de couleurs différentes
tout en conservant l'ordre d'arrivée de ces derniers afin de présenter un un affichage cohérent où le dernier morceau de tube
arrivé sur la case serait celui dessiné en dernier (afin que graphiquement il apparaisse au-dessus de l'autre). Il nous a donc
paru naturel de d'utiliser de l'héritage Avec une classe mère AbsGridElement dont héritent deux classes GridElement et
GridDelimiter (qui représente les cases avec un rond de couleur). La classe mère implémente toutes les fonctionalités qui
permettent à une case de contenir un ou plusieurs tubes et de les gérer, tandis que les classes filles implémente la gestion des
couleurs et les opérations à faire en cas de changement de taille (si on passe du mode portrait au mode paysage par exemple).
    \subsubsection{Les élements de la grille}
    Comme il a été dit auparavant, il y a deux catégorie d'éléments ceux avec un délimiteur (un rond de couleur) et ceux sans.
    Chacun de ces deux éléments possède une pile de couleurs, dès qu'un trait de couleur (tube) passe sur la case, la couleur du
    trait est empilée. On stocke alors la position de la partie du tube qui taverse la case dans une hasmap ordonnée
    (couleur->Tube). Ainsi, lorqu'on voudra savoir la couleur courante d'une case, il suffira de vérifier que la pile de couleur
    n'est pas vide, puis de renvoyer le dernier élément de cette pile. Notons que dans le cas des cases ayant un délimiteur, on
    renverra toujours la couleur du délimiteur. Ces deux classes ont également une méthode \textit{draw} qui dessine à l'écran les
    parties de tubes qui passent par la case courante. Les cases ayant un délimiteur traceront également leur rond à ce moment là.
    Les méthodes \textit{updateSize} permettent de mettre à jour les dimensions: dans le cas des délimiteurs, on recalcule le
    rayon du cercle, puis dans les deux cas, on met à jour les coordonnées des parties de tube présent sur la case. (Si la grille
    a changé de taille, les extrémités des tubes doivent être mises à jour).
    \subsubsection{Les tubes}
    Les tubes ont un début et une fin, marqués par un rond. Tant que le joueur n'a pas appuyé sur l'un des ronds, chaque rond est
    susceptible d'être un début de tube ou une fin. Un tube est complété quand les deux extrémités sont reliées. La classe tube
    doit donc posséder les coordonnées de ses extrémités, une couleur et un moyen de savoir quelle extrimité est le début. 
    Cette classe posséde donc deux taleaux l'un pour les délimiteurs, l'autre pour la suite de segments (passage d'un tube à
    l'autre) qui le compose. La classe a également un index, qui détermine le délimiteur choisi comme début de tube.
    Les segments (classe TubPart) sont mis à jour au fur et à mesure que le joueur bouge le doigt sur l'écran.
    Le fait de  stocker les segments (TubPart) dans une liste permet de facilement savoir si le point où le joueur appuie
    correspond bien au dernier élément du tube, ce qui empêche le joueur de tracer un prolongement de tubes depuis une position
    interdite.
    \subsection{Gestion du tracé}
\section{Difficultés rencontrées}
\section{Critiques et suggestions}
\end{document}
