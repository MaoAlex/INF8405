\documentclass[12pt, a4paper]{article}%{{{
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[pdftex]{graphicx}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=1]{Images/polytechnique_genie_gauche_fr_rgb.png}~\\[1.5cm]

    \textsc{\LARGE École Polytechnique Montréal}\\[2cm]

    \textsc{\Large INF8405 : Informatique Mobile}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries TP1 : FlowFree\\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=1]{Images/logoFF.png}\\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
          Philippe TROCLET \textsc{1815208}\\
          Alexandre  MAO \textsc{1813566}\\
          Fabien  BERQUEZ \textsc{1800325}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Soumis à :} M. Aurel Josas RANDOLF\\
        \emph{Soumis le :} 17 Février 2016 
      \end{flushright}
    \end{minipage}

    \vfill

  \end{center}
  \end{sffamily}
\end{titlepage}%}}}


\section{Introduction}
\section{Présentation Technique}
    \subsection{Affichage de la grille}
    Le dessin se fait en stockant des commandes qui tracent des lignes. Ainsi, nous avons une classe \textit{GridLine} qui
    contient les coordonnées des extrémités d'une ligne, lorsqu'on veut tracer la ligne, on appelle la méthode draw de cette
    classe en lui passant le canvas sur lequel on désire tracer la ligne. Les lignes sont créées lors de l'appel à la méthode
    onSizedChanged afin de connaître les dimensions de la place allouée pour la grille. On divise les dimensions par les
    dimensions de la grille (en nombre de cases). Cela nous donne les dimensions en pixels de chaques cases. On peut alors boucler
    pour tracer une droite à chaque multiple des offset sur les deux axes. Cette droite relirerait deux extrémités (verticales ou
    horizontales).
    \newline

    Les différentes lignes sont alors stockées dans une liste, afin de les parcourir dans la méthode onDraw de la vue, pour
    afficher la grille à chaque action de la part du joueur. Dans cette méthode sont également parcourus l'ensemble des éléments
    de la grille afin de leur demander de se redessiner via leur méthode draw. Ces objets seront détaillés dans la section
    suivante.
    \newline

    Il est important de souligner que l'ensemble des objets grahiques sont créés (ou mis à jour selon les cas) dans la méthode
    onSizedChanged, leurs dimensions sont alors calculées à partir des nouvelles dimensions données par la méthode onSizedChanged
    de ce fait, la grille prendra toujours toute la place possible et les divers objets graphique (ronds, traits) auront toujours
    une bonne dimension adaptée à l'écran du téléphone. Cela permet aussi d'avoir un affichage optimal quel que soit le mode
    (porttrait/paysage) dans lequel est le téléphone.
    \subsection{Fonctionnement de la grille}
    \subsubsection{La grille}
    La grille de jeu est implémentée dans la classe \textit{FlowFreeSimpleGridView}, cette classe étant la classe \textit{View}
afin de posséder toutes les fonctionnalités d'une vue, pour pouvoir intercepter les mouvements de l'utilisateur sur la surface.
Cette vue possèdera un tableau à deux dimensions (nommé grid) représentant les différentes cases de la grille. On distingue deux
types de cases, les cases classiques et les cases contenant un délimiteur. Les cases contenant un délimiteur dans la mesure où,
elles possèdent un cercle de couleur et surtout leur couleur, à tout instant, est toujours du rond présent sur la case. Nous avons
en effet considéré que qu'afin de pouvoir compléter le jeu, que les ronds soit accessibles à tout instant. En effet, dans le cas
contraire, on pourrait se retrouver bloqué dans l'état inachevé car il nous serait impossible de tracer le dernier tube, et donc
d'atteindre l'état de défaite. De ce fait nous voulions pouvoir stoquer deux classes distinctes au sein d'une même structure. De
plus, ces classes on un fonctionnement très proche: elles doivent pouvoir stocker des éléments de tube de couleurs différentes
tout en conservant l'ordre d'arrivée de ces derniers afin de présenter un un affichage cohérent où le dernier morceau de tube
arrivé sur la case serait celui dessiné en dernier (afin que graphiquement il apparaisse au-dessus de l'autre). Il nous a donc
paru naturel de d'utiliser de l'héritage Avec une classe mère AbsGridElement dont héritent deux classes GridElement et
GridDelimiter (qui représente les cases avec un rond de couleur). La classe mère implémente toutes les fonctionalités qui
permettent à une case de contenir un ou plusieurs tubes et de les gérer, tandis que les classes filles implémente la gestion des
couleurs et les opérations à faire en cas de changement de taille (si on passe du mode portrait au mode paysage par exemple).
    \subsubsection{Les élements de la grille}
    Comme il a été dit auparavant, il y a deux catégorie d'éléments ceux avec un délimiteur (un rond de couleur) et ceux sans.
    Chacun de ces deux éléments possède une pile de couleurs, dès qu'un trait de couleur (tube) passe sur la case, la couleur du
    trait est empilée. On stocke alors la position de la partie du tube qui taverse la case dans une hasmap ordonnée
    (couleur->Tube). Ainsi, lorqu'on voudra savoir la couleur courante d'une case, il suffira de vérifier que la pile de couleur
    n'est pas vide, puis de renvoyer le dernier élément de cette pile. Notons que dans le cas des cases ayant un délimiteur, on
    renverra toujours la couleur du délimiteur. Ces deux classes ont également une méthode \textit{draw} qui dessine à l'écran les
    parties de tubes qui passent par la case courante. Les cases ayant un délimiteur traceront également leur rond à ce moment là.
    Les méthodes \textit{updateSize} permettent de mettre à jour les dimensions: dans le cas des délimiteurs, on recalcule le
    rayon du cercle, puis dans les deux cas, on met à jour les coordonnées des parties de tube présent sur la case. (Si la grille
    a changé de taille, les extrémités des tubes doivent être mises à jour).
    \subsubsection{Les tubes}
    Les tubes ont un début et une fin, marqués par un rond. Tant que le joueur n'a pas appuyé sur l'un des ronds, chaque rond est
    susceptible d'être un début de tube ou une fin. Un tube est complété quand les deux extrémités sont reliées. La classe tube
    doit donc posséder les coordonnées de ses extrémités, une couleur et un moyen de savoir quelle extrimité est le début. 
    Cette classe posséde donc deux taleaux l'un pour les délimiteurs, l'autre pour la suite de segments (passage d'un tube à
    l'autre) qui le compose. La classe a également un index, qui détermine le délimiteur choisi comme début de tube.
    Les segments (classe TubPart) sont mis à jour au fur et à mesure que le joueur bouge le doigt sur l'écran.
    Le fait de  stocker les segments (TubPart) dans une liste permet de facilement savoir si le point où le joueur appuie
    correspond bien au dernier élément du tube, ce qui empêche le joueur de tracer un prolongement de tubes depuis une position
    interdite.
    \subsection{Gestion du tracé}
\section{Difficultés rencontrées}
\section{Critiques et suggestions}
\end{document}
