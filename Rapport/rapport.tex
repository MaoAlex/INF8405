\documentclass[12pt, a4paper]{article}%{{{
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[pdftex]{graphicx}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=1]{Images/polytechnique_genie_gauche_fr_rgb.png}~\\[1.5cm]

    \textsc{\LARGE École Polytechnique Montréal}\\[2cm]

    \textsc{\Large INF8405 : Informatique Mobile}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries TP1 : FlowFree\\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=1]{Images/logoFF.png}\\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
          Philippe TROCLET \textsc{1815208}\\
          Alexandre  MAO \textsc{1813566}\\
          Fabien  BERQUEZ \textsc{1800325}\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Soumis à :} M. Aurel Josas RANDOLF\\
        \emph{Soumis le :} 17 Février 2016 
      \end{flushright}
    \end{minipage}

    \vfill

  \end{center}
  \end{sffamily}
\end{titlepage}%}}}


\section{Introduction}
	L'objectif de ce laboratoire était de développer une application permettant de joueur au jeu du Flow free sur Android. Le jeu de Flow free dispose de règles assez simple : des paires de jetons de couleur sont placés sur une grille carrée d'une taille donnée (ici pour notre application, 7x7 ou 8x8). Le joueur doit alors relier chaque paire de jetons de l'un à l'autre, en traçant des tubes avec le doigt. La partie est remportée si les jetons de chaque paire sont reliés, que toutes les cases sont occupées par un tube, et qu'il n'y a aucune superposition de tubes sur une même case. Dans le cas où toutes les cases ne sont pas utilisées, la partie est inachevée. Sinon, la partie est perdue.
	\newline
	Les contraintes techniques sur cette application étaient de pouvoir être utilisée sur les versions d'Android supportant l'API 18 (Android 4.3.1) et plus (jusqu'à 23 pour la version actuelle, Android 6). Le jeu devant être adapté pour des supports mobiles variés (tablettes, téléphones intelligents, ...), il doit de plus être jouable entièrement tactilement. Enfin, l'application doit être la plus facile d'accès possible, et proposer à la fois des comportements intuitifs pour les utilisateurs de dispositifs mobiles, et une navigation facile à travers les différentes options possibles.
	\newline
	Pour respecter ces requis non-fonctionnels, nous avons donc opté pour un certain nombre de considérations d'ergonomie, sur les règles du jeu, sur les possibilités offertes au joueur. Nous allons les examiner dans la section suivante.
	
\section{Présentation générale}
	Nous allons présenter dans cette partie les choix que nous avons réalisés pour offrir aux utilisateurs de l'application une navigation et une expérience de jeu que nous espérons aisées et intuitives.
	
	\subsection{Menus de l'application}
	Nous avons opté pour un menu d'accueil proposant trois options : \textit{démarrer} une partie, accéder aux \textit{instructions} et \textit{quitter} l'application.
	Lorsque l'utilisateur choisit de démarrer la partie, un autre menu s'affiche et lui demande de choisir la taille de la grille, puis, une fois celle-ci choisie, l'utilisateur doit choisir le niveau qu'il va jouer. L'écran de jeu s'affiche alors et le joueur peut débuter. Sur les trois écrans mentionnés, l'utilisateur peut à tout moment quitter l'application en utilisant le menu dans la barre de l'application  (symbolisé sur Android 5 et 6 par les 3 points en haut à droite de la barre).
	
	\subsection{Quitter l'application}
	Pour empêcher l'utilisateur de quitter de manière involontaire l'application, le choix de quitter dans les différents menus est soumis à une confirmation, qui se fait par l'intermédiaire d'une fenêtre pop-up offrant deux choix de réponses : Oui et Non.
	
	\subsection{Déroulement du jeu}
	Une fois la partie lancée, les mécanismes impliqués pour que le joueur puisse jouer sont assez commun à beaucoup de jeux, et, nous l'espérons, intuitifs. Le joueur commence à tracer un tube d'une couleur en appuyant le doigt sur le jeton de départ qu'il a choisi, puis en maintenant appuyé pour tracer le tube de la couleur en question. Le tube en formation s'affiche au fur et à mesure que le joueur déplace son doigt. Lorsque le joueur relève le doigt, le tracé s'arrête, mais le joueur à la possibilité de continuer à tout moment le trait qu'il vient d'interrompre en appuyant le doigt sur l'extrémité actuelle du tube. Sinon, il peut passer à un autre jeton de départ (et une autre couleur) ou bien poursuivre un autre tracé.
	\newline
	Afin d'offrir un confort maximal et de permettre au joueur de ne pas avoir à recommencer à chaque erreur de tracé, une fonction d'annulation a été incluse. Elle permet d'effacer du plus récent au plus ancien les derniers morceaux de tubes qui ont été tracés. Une fonction de réinitialisation est également présente pour revenir à la configuration de départ du niveau.
	
	\subsection{Instructions}
	Pour présenter au joueur des informations utiles à son expérience de jeu, nous avons introduit dans le menu principal un accès aux instructions du jeu. Celle ci sont présentées dans un écran dédié, scrollable, et structurées en divers sections, présentant respectivement les règles et mécanismes du jeu, les conditions de victoire, les conditions de défaite, le schéma de progression et de navigation dans les niveaux. Enfin un petit mot est mis sur la possibilité de quitter le jeu via les menus dédiés.
	\newline
	Nous avons vu les principaux choix concernant l'ergonomie et les mécanismes de jeu offerts à l'utilisateur. Dans la section suivante, nous détaillerons les choix techniques effectués pour réaliser l'application.
		 
\section{Présentation Technique}
    \subsection{Affichage de la grille}
    Le dessin se fait en stockant des commandes qui tracent des lignes. Ainsi, nous avons une classe \textit{GridLine} qui
    contient les coordonnées des extrémités d'une ligne, lorsqu'on veut tracer la ligne, on appelle la méthode draw de cette
    classe en lui passant le canvas sur lequel on désire tracer la ligne. Les lignes sont créées lors de l'appel à la méthode
    onSizedChanged afin de connaître les dimensions de la place allouée pour la grille. On divise les dimensions par les
    dimensions de la grille (en nombre de cases). Cela nous donne les dimensions en pixels de chaques cases. On peut alors boucler
    pour tracer une droite à chaque multiple des offset sur les deux axes. Cette droite relirerait deux extrémités (verticales ou
    horizontales).
    \newline

    Les différentes lignes sont alors stockées dans une liste, afin de les parcourir dans la méthode onDraw de la vue, pour
    afficher la grille à chaque action de la part du joueur. Dans cette méthode sont également parcourus l'ensemble des éléments
    de la grille afin de leur demander de se redessiner via leur méthode draw. Ces objets seront détaillés dans la section
    suivante.
    \newline

    Il est important de souligner que l'ensemble des objets grahiques sont créés (ou mis à jour selon les cas) dans la méthode
    onSizedChanged, leurs dimensions sont alors calculées à partir des nouvelles dimensions données par la méthode onSizedChanged
    de ce fait, la grille prendra toujours toute la place possible et les divers objets graphique (ronds, traits) auront toujours
    une bonne dimension adaptée à l'écran du téléphone. Cela permet aussi d'avoir un affichage optimal quel que soit le mode
    (porttrait/paysage) dans lequel est le téléphone.
    \subsection{Fonctionnement de la grille}
    \subsubsection{La grille}
    La grille de jeu est implémentée dans la classe \textit{FlowFreeSimpleGridView}, cette classe étant la classe \textit{View}
afin de posséder toutes les fonctionnalités d'une vue, pour pouvoir intercepter les mouvements de l'utilisateur sur la surface.
Cette vue possèdera un tableau à deux dimensions (nommé grid) représentant les différentes cases de la grille. On distingue deux
types de cases, les cases classiques et les cases contenant un délimiteur. Les cases contenant un délimiteur dans la mesure où,
elles possèdent un cercle de couleur et surtout leur couleur, à tout instant, est toujours du rond présent sur la case. Nous avons
en effet considéré que qu'afin de pouvoir compléter le jeu, que les ronds soit accessibles à tout instant. En effet, dans le cas
contraire, on pourrait se retrouver bloqué dans l'état inachevé car il nous serait impossible de tracer le dernier tube, et donc
d'atteindre l'état de défaite. De ce fait nous voulions pouvoir stoquer deux classes distinctes au sein d'une même structure. De
plus, ces classes on un fonctionnement très proche: elles doivent pouvoir stocker des éléments de tube de couleurs différentes
tout en conservant l'ordre d'arrivée de ces derniers afin de présenter un un affichage cohérent où le dernier morceau de tube
arrivé sur la case serait celui dessiné en dernier (afin que graphiquement il apparaisse au-dessus de l'autre). Il nous a donc
paru naturel de d'utiliser de l'héritage Avec une classe mère AbsGridElement dont héritent deux classes GridElement et
GridDelimiter (qui représente les cases avec un rond de couleur). La classe mère implémente toutes les fonctionalités qui
permettent à une case de contenir un ou plusieurs tubes et de les gérer, tandis que les classes filles implémente la gestion des
couleurs et les opérations à faire en cas de changement de taille (si on passe du mode portrait au mode paysage par exemple).
    \subsubsection{Les élements de la grille}
    Comme il a été dit auparavant, il y a deux catégorie d'éléments ceux avec un délimiteur (un rond de couleur) et ceux sans.
    Chacun de ces deux éléments possède une pile de couleurs, dès qu'un trait de couleur (tube) passe sur la case, la couleur du
    trait est empilée. On stocke alors la position de la partie du tube qui taverse la case dans une hasmap ordonnée
    (couleur->Tube). Ainsi, lorqu'on voudra savoir la couleur courante d'une case, il suffira de vérifier que la pile de couleur
    n'est pas vide, puis de renvoyer le dernier élément de cette pile. Notons que dans le cas des cases ayant un délimiteur, on
    renverra toujours la couleur du délimiteur. Ces deux classes ont également une méthode \textit{draw} qui dessine à l'écran les
    parties de tubes qui passent par la case courante. Les cases ayant un délimiteur traceront également leur rond à ce moment là.
    Les méthodes \textit{updateSize} permettent de mettre à jour les dimensions: dans le cas des délimiteurs, on recalcule le
    rayon du cercle, puis dans les deux cas, on met à jour les coordonnées des parties de tube présent sur la case. (Si la grille
    a changé de taille, les extrémités des tubes doivent être mises à jour).
    \subsubsection{Les tubes}
    Les tubes ont un début et une fin, marqués par un rond. Tant que le joueur n'a pas appuyé sur l'un des ronds, chaque rond est
    susceptible d'être un début de tube ou une fin. Un tube est complété quand les deux extrémités sont reliées. La classe tube
    doit donc posséder les coordonnées de ses extrémités, une couleur et un moyen de savoir quelle extrimité est le début. 
    Cette classe posséde donc deux taleaux l'un pour les délimiteurs, l'autre pour la suite de segments (passage d'un tube à
    l'autre) qui le compose. La classe a également un index, qui détermine le délimiteur choisi comme début de tube.
    Les segments (classe TubPart) sont mis à jour au fur et à mesure que le joueur bouge le doigt sur l'écran.
    Le fait de  stocker les segments (TubPart) dans une liste permet de facilement savoir si le point où le joueur appuie
    correspond bien au dernier élément du tube, ce qui empêche le joueur de tracer un prolongement de tubes depuis une position
    interdite. Cette manière de faire permet également de facilement savoir facilement si le tube est fini.
    \newline

    Sachant que l'utilisateur doit relier tous les ronds entre eux pour pouvoir gagner, et que donc à terme tous les tubes
    existeront, ils sont tous créés lors de l'initialisation de la partie. En revanche, ils seront initialisés, c'est-à-dire que
    le délimiteur qui marque le début sera désigné au moment où l'utilisateur appuiera pour la première fois sur un rond de cette
    couleur. Qui sera alors désigné comme étant le délimiteur de début pour ce tube.
    \subsection{Gestion du tracé}
    Lorsque l'utilisateur appuie sur l'écran, on recupère les coordonnées via l'event, on les divise par la largeur et la longueur
    d'une case via une division entière, cela nous donne les coordonnées de la case sous la forme (i,j). On peut alors directement
    accéder à la case choisie par l'utilisateur en utilisant le fait que les case sont contenues dans un tableau à deux
    dimensions. On met alors à jour le tube correspondant à la couleur actuelle (via la hashmap couleur -> tube). Cette mise à
    jour, passe par la création d'un objet TubPart qui caractérise le fait qu'un tube passe par une case. Cette objet sert de
    conteneur pour deux "morceaux" de tube. (Ces morceaux sont en réalité des segments graphiques reliant le centre de la case aux
    bords de la case suivante et de la case précédente dans le tube). Ainsi, un tube n'est qu'une succession de segment qui sont
    tracés à la suite, la sensation de continuité povient du fait que les extrémités du dit segment se superposent.
    \newline

    Remarque; lors du tracé, il faut vérifier que le mouvement fait par l'utilisateur est cohérent, c'est-à-dire qu'il va sur une
    case à côté de la case de départ, dont la couleur est différente de la case sauf s'il se rend sur le délimiteur qui ferme le
    tube.
\section{Difficultés rencontrées}
\section{Critiques et suggestions}
\end{document}
